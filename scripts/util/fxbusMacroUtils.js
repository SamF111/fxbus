// D:\FoundryVTT\Data\modules\fxbus\scripts\util\fxbusMacroUtils.js

/**
 * FX Bus - Macro Utilities
 *
 * Responsibilities:
 * - Build a standalone Foundry macro script that replays an FX Bus "Apply" by emitting a payload via the FX Bus runtime.
 * - Copy macro source text to clipboard with robust fallbacks.
 * - Optional helper to create/update a Macro document (not required for clipboard workflow).
 *
 * Design constraints:
 * - Macro script must be self-contained and not depend on the GM panel UI.
 * - Macro script must not mutate documents; it should only emit FX messages.
 * - Clipboard operations must be initiated by a user gesture; this module only provides primitives.
 *
 * Compatibility:
 * - Foundry VTT v12+ (tested patterns); intended for v13+.
 */

const MODULE_ID = "fxbus";
const DEFAULT_SOCKET_NAMESPACE = `module.${MODULE_ID}`;

/**
 * Build the source code for a Foundry script macro that emits an FX Bus payload.
 *
 * Important:
 * - FX Bus in your architecture is runtime-driven (`globalThis.fxbus.emit`) not socket-driven.
 * - Emitting directly to `game.socket.emit("module.fxbus", payload)` will do nothing unless you also
 *   register a raw socket listener. Therefore, the generated macro calls the runtime.
 *
 * Player-runnable:
 * - Default is player-runnable (no GM guard).
 * - Set requireGM=true only when you explicitly want to restrict the macro to GMs.
 *
 * @param {string} macroName - Human-friendly macro name for header comments.
 * @param {object} payload - Payload to emit via the FX Bus runtime.
 * @param {object} options
 * @param {string} [options.socketNamespace] - Kept for compatibility; not used unless forceSocket=true.
 * @param {boolean} [options.requireGM] - If true, macro returns immediately for non-GM users.
 * @param {boolean} [options.forceSocket] - If true, emit to socket directly instead of runtime (not recommended).
 * @returns {string} JavaScript macro source.
 */
export function fxbusBuildMacroSource(
  macroName,
  payload,
  {
    socketNamespace = DEFAULT_SOCKET_NAMESPACE,
    requireGM = false,
    forceSocket = false
  } = {}
) {
  const safeName = String(macroName ?? "FX Bus Macro").trim() || "FX Bus Macro";

  if (!payload || typeof payload !== "object") {
    throw new Error("fxbusBuildMacroSource: payload must be an object");
  }

  // JSON.stringify is the safest serialisation for payload transport.
  const payloadJson = JSON.stringify(payload, null, 2);

  const emitLine = forceSocket
    ? `game.socket.emit(${JSON.stringify(String(socketNamespace))}, payload);`
    : `globalThis.fxbus?.emit?.(payload);`;

  const runtimeGuard = forceSocket
    ? ""
    : `  if (!globalThis.fxbus?.emit) {
    ui.notifications?.error?.("FX Bus runtime not available.");
    return;
  }`;

  return `/**
 * ${safeName}
 *
 * Generated by FX Bus GM Control Panel.
 * Replays an FX Bus "Apply" by emitting the same payload.
 *
 * Behaviour:
 * - Visual-only. Does not update Documents.
 * - Runs on every connected client that has FX Bus active.
 */

(() => {
  ${requireGM ? "if (!game.user.isGM) return;" : ""}
${runtimeGuard}
  const payload = ${payloadJson};
  ${emitLine}
})();`;
}

/**
 * Copy text to the system clipboard.
 *
 * Primary:
 * - navigator.clipboard.writeText (requires secure context + user gesture)
 *
 * Fallback:
 * - document.execCommand("copy") using a temporary textarea
 *
 * @param {string} text
 * @returns {Promise<void>}
 */
export async function fxbusCopyTextToClipboard(text) {
  const value = String(text ?? "");

  if (!value.length) {
    throw new Error("fxbusCopyTextToClipboard: empty text");
  }

  // Primary: modern Clipboard API
  if (globalThis.navigator?.clipboard?.writeText) {
    await globalThis.navigator.clipboard.writeText(value);
    return;
  }

  // Fallback: legacy copy command
  const textarea = document.createElement("textarea");
  textarea.value = value;

  // Keep offscreen; avoid scroll jump.
  textarea.style.position = "fixed";
  textarea.style.top = "-1000px";
  textarea.style.left = "-1000px";
  textarea.style.width = "1px";
  textarea.style.height = "1px";
  textarea.style.opacity = "0";

  document.body.appendChild(textarea);
  textarea.focus();
  textarea.select();

  const ok = document.execCommand("copy");
  document.body.removeChild(textarea);

  if (!ok) throw new Error("fxbusCopyTextToClipboard: execCommand copy failed");
}

/**
 * Optional: Create or update a Foundry Macro document containing the given command.
 *
 * Notes:
 * - Not required if your workflow is clipboard-only.
 * - If you use this, you may also want to auto-place it on the hotbar.
 *
 * @param {string} macroName
 * @param {string} macroSource
 * @param {object} options
 * @param {boolean} [options.globalScope] - If true, creates a global macro; else user macro.
 * @returns {Promise<Macro>}
 */
export async function fxbusCreateOrUpdateMacro(
  macroName,
  macroSource,
  { globalScope = true } = {}
) {
  const name = String(macroName ?? "").trim();
  const command = String(macroSource ?? "");

  if (!name.length) throw new Error("fxbusCreateOrUpdateMacro: macroName required");
  if (!command.length) throw new Error("fxbusCreateOrUpdateMacro: macroSource required");

  const existing = game.macros?.find?.((m) => m.name === name && m.type === "script") ?? null;

  if (existing) {
    await existing.update({ command });
    return existing;
  }

  // Scope behaviour varies slightly by version; "global" is standard for shared macros.
  return Macro.create({
    name,
    type: "script",
    scope: globalScope ? "global" : "user",
    command,
    ownership: { default: CONST.DOCUMENT_OWNERSHIP_LEVELS.OWNER }
  });
}
