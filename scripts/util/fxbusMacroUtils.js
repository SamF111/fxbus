// D:\FoundryVTT\Data\modules\fxbus\scripts\util\fxbusMacroUtils.js

/**
 * FX Bus - Macro Utilities
 *
 * Responsibilities:
 * - Build a standalone Foundry macro script that replays an FX Bus "Apply" by emitting a payload via the FX Bus runtime.
 * - Copy macro source text to clipboard with robust fallbacks.
 * - Optional helper to create/update a Macro document (not required for clipboard workflow).
 *
 * Design constraints:
 * - Macro script must be self-contained and not depend on the GM panel UI.
 * - Macro script must not mutate documents; it should only emit FX messages.
 * - Clipboard operations must be initiated by a user gesture; this module only provides primitives.
 *
 * Compatibility:
 * - Foundry VTT v12+ (tested patterns); intended for v13+.
 */

const MODULE_ID = "fxbus";
const DEFAULT_SOCKET_NAMESPACE = `module.${MODULE_ID}`;

function safeStr(value, fallback = "") {
  const s = String(value ?? "").trim();
  return s.length ? s : fallback;
}

function jsStringLiteral(value) {
  // Safe for embedding in a JS template literal.
  return String(value ?? "")
    .replace(/\\/g, "\\\\")
    .replace(/`/g, "\\`")
    .replace(/\$\{/g, "\\${");
}

function buildHeaderCommentLines({
  macroName,
  payload,
  generatedAtIso,
  generatedBy,
  fxbusVersion
}) {
  const action = safeStr(payload?.action, "fx.unknown");
  const name = safeStr(macroName, "FX Bus Macro");

  const lines = [
    "/**",
    ` * ${jsStringLiteral(name)}`,
    " *",
    " * Generated by FX Bus GM Control Panel.",
    ` * Action: ${jsStringLiteral(action)}`,
    generatedAtIso ? ` * Generated: ${jsStringLiteral(generatedAtIso)}` : null,
    generatedBy ? ` * User: ${jsStringLiteral(generatedBy)}` : null,
    fxbusVersion ? ` * FX Bus: v${jsStringLiteral(fxbusVersion)}` : null,
    " *",
    " * Behaviour:",
    " * - Visual-only. Does not update Documents.",
    " * - Runs on every connected client that has FX Bus active.",
    " */"
  ].filter(Boolean);

  return lines.join("\n");
}

/**
 * Build the source code for a Foundry script macro that emits an FX Bus payload.
 *
 * Important:
 * - FX Bus in your architecture is runtime-driven (`globalThis.fxbus.emit`) not socket-driven.
 * - Emitting directly to `game.socket.emit("module.fxbus", payload)` will do nothing unless you also
 *   register a raw socket listener. Therefore, the generated macro calls the runtime.
 *
 * Player-runnable:
 * - Default is player-runnable (no GM guard).
 * - Set requireGM=true only when you explicitly want to restrict the macro to GMs.
 *
 * Metadata:
 * - The generated macro header can include generation metadata (date/user/module version).
 * - Provide these via options.meta to avoid relying on the GM panel at build time.
 *
 * @param {string} macroName - Human-friendly macro name for header comments.
 * @param {object} payload - Payload to emit via the FX Bus runtime.
 * @param {object} options
 * @param {string} [options.socketNamespace] - Kept for compatibility; not used unless forceSocket=true.
 * @param {boolean} [options.requireGM] - If true, macro returns immediately for non-GM users.
 * @param {boolean} [options.forceSocket] - If true, emit to socket directly instead of runtime (not recommended).
 * @param {object} [options.meta]
 * @param {string} [options.meta.generatedAt] - ISO string timestamp (recommended).
 * @param {string} [options.meta.generatedBy] - User name.
 * @param {string} [options.meta.fxbusVersion] - Module version string.
 * @returns {string} JavaScript macro source.
 */
export function fxbusBuildMacroSource(
  macroName,
  payload,
  {
    socketNamespace = DEFAULT_SOCKET_NAMESPACE,
    requireGM = false,
    forceSocket = false,
    meta = {}
  } = {}
) {
  const safeName = safeStr(macroName, "FX Bus Macro");

  if (!payload || typeof payload !== "object") {
    throw new Error("fxbusBuildMacroSource: payload must be an object");
  }

  const payloadJson = JSON.stringify(payload, null, 2);

  const emitLine = forceSocket
    ? `game.socket.emit(${JSON.stringify(String(socketNamespace))}, payload);`
    : `globalThis.fxbus?.emit?.(payload);`;

  const runtimeGuard = forceSocket
    ? ""
    : `  if (!globalThis.fxbus?.emit) {
    ui.notifications?.error?.("FX Bus runtime not available.");
    return;
  }`;

  const header = buildHeaderCommentLines({
    macroName: safeName,
    payload,
    generatedAtIso: safeStr(meta?.generatedAt, ""),
    generatedBy: safeStr(meta?.generatedBy, ""),
    fxbusVersion: safeStr(meta?.fxbusVersion, "")
  });

  return `${header}

(() => {
  ${requireGM ? "if (!game.user.isGM) return;" : ""}
${runtimeGuard}
  const payload = ${payloadJson};
  ${emitLine}
})();`;
}

/**
 * Copy text to the system clipboard.
 *
 * Primary:
 * - navigator.clipboard.writeText (requires secure context + user gesture)
 *
 * Fallback:
 * - document.execCommand("copy") using a temporary textarea
 *
 * @param {string} text
 * @returns {Promise<void>}
 */
export async function fxbusCopyTextToClipboard(text) {
  const value = String(text ?? "");

  if (!value.length) {
    throw new Error("fxbusCopyTextToClipboard: empty text");
  }

  if (globalThis.navigator?.clipboard?.writeText) {
    await globalThis.navigator.clipboard.writeText(value);
    return;
  }

  const textarea = document.createElement("textarea");
  textarea.value = value;

  textarea.style.position = "fixed";
  textarea.style.top = "-1000px";
  textarea.style.left = "-1000px";
  textarea.style.width = "1px";
  textarea.style.height = "1px";
  textarea.style.opacity = "0";

  document.body.appendChild(textarea);
  textarea.focus();
  textarea.select();

  const ok = document.execCommand("copy");
  document.body.removeChild(textarea);

  if (!ok) throw new Error("fxbusCopyTextToClipboard: execCommand copy failed");
}

/**
 * Optional: Create or update a Foundry Macro document containing the given command.
 *
 * Notes:
 * - Not required if your workflow is clipboard-only.
 * - If you use this, you may also want to auto-place it on the hotbar.
 *
 * @param {string} macroName
 * @param {string} macroSource
 * @param {object} options
 * @param {boolean} [options.globalScope] - If true, creates a global macro; else user macro.
 * @returns {Promise<Macro>}
 */
export async function fxbusCreateOrUpdateMacro(
  macroName,
  macroSource,
  { globalScope = true } = {}
) {
  const name = String(macroName ?? "").trim();
  const command = String(macroSource ?? "");

  if (!name.length) throw new Error("fxbusCreateOrUpdateMacro: macroName required");
  if (!command.length) throw new Error("fxbusCreateOrUpdateMacro: macroSource required");

  const existing =
    game.macros?.find?.((m) => m.name === name && m.type === "script") ?? null;

  if (existing) {
    await existing.update({ command });
    return existing;
  }

  return Macro.create({
    name,
    type: "script",
    scope: globalScope ? "global" : "user",
    command,
    ownership: { default: CONST.DOCUMENT_OWNERSHIP_LEVELS.OWNER }
  });
}
